"""「Python作業_第八組.jpynb」

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MZp9GRCyv3nwDYpXeDdN3mnNRP0BcDZ-
"""

組員名單:羅傳硯 賴柏翰 陳奕君 周湘庭
#1請將「imdb_top_1000.xlsx」檔案存到你的Google雲端硬碟中，並分享檔案權限的方式讀取檔案中『Data』工作表中的資料，並命名為imdb1000資料集。(10%)

from google.colab import drive

drive.mount('/content/drive')

imdb1000 = pd.read_excel('https://docs.google.com/spreadsheets/d/1Aqdh2xoGdTSUhTCY3bHdeMX8EWAKz5hd/edit#gid=1826780789')

print(imdb1000.info)

#2請將imdb1000中欄位名稱為「Series_Title」改成「電影片名」；「Runtime」改為「影片長度」並重新存回imdb1000 (5%)。
new_column_names = {
    'Series_Title': '電影片名',
    'Runtime': '影片長度',
}
imdb1000 = imdb1000.rename(columns=new_column_names)
print(imdb1000.info)

#3請用info指令檢視資料集中變數是否符合「imdb_top_1000.xlsx」檔案中『變數定義』所認定之定義；若不是，請將該變數轉型成適當的資料型別(10%)。

print(imdb1000.info())
imdb1000['影片長度'] = imdb1000['影片長度'].astype(float)
imdb1000['IMDB_Rating'] = imdb1000['IMDB_Rating'].astype(float)
imdb1000['Meta_score'] = imdb1000['Meta_score'].astype(float)
imdb1000['No_of_Votes'] = imdb1000['No_of_Votes'].astype(int)
imdb1000['Gross'] = imdb1000['Gross'].astype(float)

#4請將imdb1000中有遺失值的列刪除，另存成imdb_drop(5%)。
imdb_drop = imdb1000.dropna()

#5請用「if…elif…elif…else…判斷式」將imdb_drop中「IMDB_Rating」重新定義一個變數為『評等』存回imdb_drop這個資料集內，變數定義如下：(10%)
A   >= 9.0
B   < 9.0 and >= 8.5
C   <8.5 and >= 8.0
D   <8.0

def assign_rating(imdb_rating):
    if imdb_rating >= 9.0:
        return 'A'
    elif imdb_rating < 9.0 and imdb_rating >= 8.5:
        return 'B'
    elif imdb_rating < 8.5 and imdb_rating >= 8.0:
        return 'C'
    else:
        return 'D'

imdb_drop['評等'] = imdb_drop['IMDB_Rating'].apply(assign_rating)

#6請將imdb_drop中的「電影片名」定義成index並重新存回imdb_drop (5%)。


imdb_drop.set_index('Series_Title', inplace=True)

#7請將imdb_drop中「影片長度」、「IMDB_Rating」、「Meta_score」、「No_of_Votes」、「Gross」5個欄位資料另存為imdb_numeric資料集(5%)。

imdb_numeric = imdb_data[['Runtime', 'IMDB_Rating', 'Meta_score', 'No_of_Votes', 'Gross']]

imdb_numeric['Gross'] = imdb_numeric['Gross'].str.replace(',', '').astype(float)

#8計算imdb_numeric所有欄位的平均數、標準差、最大值、最小值，以及變數間的共變異數及相關係數矩陣(10%)
mean_values = imdb_numeric.mean()

std_values = imdb_numeric.std()

max_values = imdb_numeric.max()

min_values = imdb_numeric.min()

cov_matrix = imdb_numeric.cov()

corr_matrix = imdb_numeric.corr()

#9
imdb_rate = imdb_drop[['評等']]

#10請將imdb_drop中「評等」另存成imdb_rate的資料集(5%)。

imdb_numeric = imdb_data[['Series_Title', 'IMDB_Rating', 'Meta_score', 'No_of_Votes']]

imdb_rate = imdb_data.copy()

imdb_merge = pd.merge(imdb_rate, imdb_numeric, on='Series_Title', suffixes=('_rate', '_numeric'))

#11以imdb_merge中「評等」進行資料分組，分別計算其「影片長度」、「IMDB_Rating」、「Meta_score」、「No_of_Votes」、「Gross」5個變數的平均數、個數(10%)。

grouped_data = imdb_merge.groupby('IMDB_Rating_rate').agg({
    'Runtime': 'mean',
    'IMDB_Rating_rate': 'mean',
    'Meta_score_rate': 'mean',
    'No_of_Votes_rate': 'mean',
    'Gross': 'mean'
}).reset_index()

#12請以imdb_drop中「Certificate」項目的次數分配表繪製圓餅圖，並命名該圖表的title為『認證項目圓餅圖』(10%)。

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

certificate_counts = imdb_data['Certificate'].value_counts()

plt.figure(figsize=(8, 8))
certificate_counts.plot(kind='pie', autopct='%1.1f%%', startangle=140)
plt.title('認證項目圓餅圖')
plt.ylabel('')

#13請篩選imdb_drop中「Certificate」為U的項目，且欄位保留「Certificate」及「Meta_Score」2個變數，另存成imdb_U資料集(5%)。

imdb_U = imdb_data[imdb_data['Certificate'] == 'U'][['Certificate', 'Meta_score']]

#14請繪製imdb_U中「Meta_Score」變數的莖葉圖(5%)。

meta_scores = imdb_U['Meta_score'].dropna()
plt.figure(figsize=(10, 6))
(markerline, stemlines, baseline) = plt.stem(meta_scores)
plt.setp(stemlines, 'color', plt.getp(markerline, 'color'))
plt.title('Meta_Score 變數的莖葉圖')
plt.xlabel('Index')
plt.ylabel('Meta_Score')
plt.show()

#15.請繪製imdb_drop中「No_of_Votes」的盒鬚圖（以「評等」進行分組）(10%)。

plt.figure(figsize=(10, 6))
imdb_drop.boxplot(column='No_of_Votes', by='評等', grid=False)
plt.title('No_of_Votes的盒鬚圖')
plt.suptitle('')
plt.xlabel('評等')
plt.ylabel('No_of_Votes')
plt.show()